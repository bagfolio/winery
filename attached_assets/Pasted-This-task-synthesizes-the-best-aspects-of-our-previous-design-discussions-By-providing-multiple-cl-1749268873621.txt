This task synthesizes the best aspects of our previous design discussions. By providing multiple, clear paths for users to create content and fixing the final bug in the editor's data flow, we will deliver the sleek, powerful, and seamless experience that has been our goal from the start.
How to Implement
Part 1: Fix the Core Bug in QuestionConfigForm.tsx
File to Modify: client/src/components/editor/QuestionConfigForm.tsx
The Problem: The multiple_choice options are not being rendered because the map function expects a value property on each option object, but our template only provides text.
The Fix: Update the key and value props in the Input components to use the option's text property if a unique value or id is not present. This makes the component more robust.
// In QuestionConfigForm.tsx, inside the multiple choice .map()

// CHANGE THIS:
{payload.options?.map((option: any, index: number) => (
  <div key={index} /* ... */>
    {/* ... */}
    <Input value={option.text || ''} onChange={(e) => handleOptionChange(index, 'text', e.target.value)} /* ... */ />
    {/* ... */}
  </div>
))}

// TO THIS:
{payload.options?.map((option: any, index: number) => (
  // Use a more stable key, and ensure the value prop is correctly set
  <div key={option.value || option.text || index} /* ... */>
    {/* ... */}
    <Input value={option.text || ''} onChange={(e) => handleOptionChange(index, 'text', e.target.value)} /* ... */ />
    <Input value={option.description || ''} onChange={(e) => handleOptionChange(index, 'description', e.target.value)} /* ... */ />
    {/* Add a hidden or visible input for the 'value' if it needs to be distinct from 'text' */}
  </div>
))}
Use code with caution.
Tsx
A more robust fix is to ensure the addOption function creates a unique ID for each option.
Correct addOption function:
// In QuestionConfigForm.tsx
const addOption = () => {
  // Create a unique value for the new option
  const newValue = `option_${Date.now()}`;
  const newOptions = [...(payload.options || []), { text: '', description: '', value: newValue }];
  handleFieldChange('options', newOptions);
};
Use code with caution.
TypeScript
Part 2: Implement the Hybrid UI in PackageEditor.tsx
File to Modify: client/pages/PackageEditor.tsx
Ensure SLIDE_TEMPLATES is imported:
import { SLIDE_TEMPLATES } from '@/lib/wineTemplates';
Use code with caution.
TypeScript
Update handleAddSlide: Make it flexible to handle both UI flows.
const handleAddSlide = (wineId: string, template: any, sectionType?: 'intro' | 'deep_dive' | 'ending') => {
  const wineSlides = slides.filter(s => s.packageWineId === wineId);
  const nextPosition = (wineSlides.length > 0 ? Math.max(...wineSlides.map(s => s.position)) : 0) + 1;

  const slideData = {
    packageWineId: wineId,
    position: nextPosition,
    type: template.type,
    // Use the explicit sectionType if provided (from popover), otherwise use the template's default
    section_type: sectionType || template.sectionType,
    payloadJson: {
      title: template.name,
      description: template.description || '',
      ...(template.payloadTemplate || {}),
    },
  };
  createSlideMutation.mutate(slideData);
};
Use code with caution.
TypeScript
Update the Sidebar JSX: Replace the content of the expanded wine card's motion.div (the one inside the AnimatePresence block) with this hybrid code:
<motion.div initial={{ height: 0, opacity: 0 }} animate={{ height: 'auto', opacity: 1 }} exit={{ height: 0, opacity: 0 }} className="pl-4 mt-2 border-l-2 border-white/10 ml-5 space-y-4 py-2">
  {/* --- SECTION-BASED UI --- */}
  {Object.entries(sectionDetails).map(([key, { title, icon }]) => {
    const sectionSlides = wineSlides.filter(s => s.section_type === key);
    return (
      <div key={key}>
        <div className="flex items-center justify-between mb-1">
          <h4 className="text-sm font-semibold text-white/90 flex items-center">{icon}<span className="ml-2">{title}</span></h4>
          <Popover>
            <PopoverTrigger asChild><Button size="icon" variant="ghost" className="h-6 w-6 text-purple-300 hover:bg-purple-500/20 hover:text-purple-200"><Plus className="h-4 w-4" /></Button></PopoverTrigger>
            <PopoverContent className="w-56 p-1 bg-gray-900/80 border-gray-700 backdrop-blur-md">
              <div className="space-y-1">
                {SLIDE_TEMPLATES.map(template => (
                  <Button key={template.id || template.name} variant="ghost" className="w-full justify-start font-normal h-8 text-white/80" onClick={() => handleAddSlide(wine.id, key as any, template)}>
                    <PlusCircle className="mr-2 h-4 w-4 text-purple-400" />{template.name}
                  </Button>
                ))}
              </div>
            </PopoverContent>
          </Popover>
        </div>
        <div className="pl-4 space-y-1">
          {sectionSlides.length > 0 ? (
            sectionSlides.map(slide => (
              <div key={slide.id} className={`p-2 rounded-md cursor-pointer transition-colors ${activeSlideId === slide.id ? 'bg-purple-600/30' : 'hover:bg-white/10'}`} onClick={() => setActiveSlideId(slide.id)}>
                <p className="text-sm font-medium text-white truncate">{(slide.payloadJson as any)?.title || 'Untitled Slide'}</p>
              </div>
            ))
          ) : <p className="text-xs text-white/50 italic px-2 py-1">No slides in this section.</p>}
        </div>
      </div>
    );
  })}

  {/* --- FULL TEMPLATE LIST UI --- */}
  <div className="mt-4 pt-4 border-t border-white/10">
    {SLIDE_TEMPLATES.map(template => (
      <Button key={template.id || template.name} size="sm" variant="ghost" className="w-full text-sm h-9 justify-start text-white/70 hover:text-white hover:bg-white/5" onClick={() => handleAddSlide(wine.id, template)} title={template.description}>
        {template.icon && <template.icon className="mr-2 h-4 w-4 flex-shrink-0 text-purple-400" />}
        <span className="truncate">Add {template.name}</span>
      </Button>
    ))}
  </div>
</motion.div>
Use code with caution.
Tsx
This final, combined approach provides the best possible user experience and corrects all underlying data flow issues.