The Supabase database slides table has already been updated (via SQL) to support new type values: 'video_message' and 'audio_message'. We now need to update the application code (Drizzle schema and frontend React components) to fully integrate and display these types of media slides. Media files (MP4s, audio files) will be hosted on Supabase Storage, and their public URLs will be stored in the payload_json of the respective slides.

Objective (What):

Update shared/schema.ts to reflect the new 'video_message' and 'audio_message' slide types, including defining example Zod schemas for their payload_json.
Modify client/src/pages/TastingSession.tsx to render HTML5 <video> and <audio> elements when these new slide types are encountered.
Update server/storage.ts (specifically initializeWineTastingData) to include an example of how a 'video_message' slide would be created with a placeholder URL, demonstrating the payload structure.
Implementation Details (How):

1. Update Drizzle Schema & Zod Types (shared/schema.ts)

Action: Modify the slides table definition and related Zod schemas.
TypeScript

// In shared/schema.ts

import { pgTable, text, uuid, integer, /* other imports */ jsonb, varchar, index, unique } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

// ... (packages table definition) ...

// Define all allowed slide types, including the new ones
const slideTypes = ['question', 'media', 'interlude', 'video_message', 'audio_message'] as const;

export const slides = pgTable("slides", {
  id: uuid("id").primaryKey().defaultRandom(),
  packageId: uuid("package_id").references(() => packages.id, { onDelete: "cascade" }),
  position: integer("position").notNull(),
  type: varchar("type", { length: 50 }).$type<typeof slideTypes[number]>().notNull(), // The DB CHECK constraint handles enforcement
  payloadJson: jsonb("payload_json").notNull(),
  createdAt: timestamp("created_at").defaultNow()
}, (table) => ({
  packagePositionIdx: index("idx_slides_package_position").on(table.packageId, table.position)
}));

// --- Define Zod schemas for the payloads of new slide types ---
export const videoMessagePayloadSchema = z.object({
  title: z.string().optional(),
  description: z.string().optional(),
  video_url: z.string().url({ message: "Invalid video URL" }),
  poster_url: z.string().url({ message: "Invalid poster URL" }).optional(),
  autoplay: z.boolean().default(false).optional(),
  show_controls: z.boolean().default(true).optional()
});
export type VideoMessagePayload = z.infer<typeof videoMessagePayloadSchema>;

export const audioMessagePayloadSchema = z.object({
  title: z.string().optional(),
  description: z.string().optional(),
  audio_url: z.string().url({ message: "Invalid audio URL" }),
  autoplay: z.boolean().default(false).optional(),
  show_controls: z.boolean().default(true).optional()
});
export type AudioMessagePayload = z.infer<typeof audioMessagePayloadSchema>;

// --- Define existing payload schemas (you might have these already or need to define them) ---
// Example for Interlude (ensure it matches your current structure)
export const interludePayloadSchema = z.object({
    title: z.string(),
    description: z.string().optional(),
    wine_name: z.string().optional(),
    wine_image: z.string().url().optional()
});
export type InterludePayload = z.infer<typeof interludePayloadSchema>;

// Example for Question (ensure it matches your current structure)
export const questionPayloadSchema = z.object({
    title: z.string(),
    description: z.string().optional(),
    question_type: z.enum(['multiple_choice', 'scale' /*, add other question types */]),
    category: z.string().optional(),
    // Add other question-specific fields like options, scale_min, scale_max etc.
    // This is a simplified example; your actual question payload is more complex.
    options: z.array(z.object({ id: z.string(), text: z.string(), description: z.string().optional() })).optional(),
    scale_min: z.number().optional(),
    scale_max: z.number().optional(),
    scale_labels: z.tuple([z.string(), z.string()]).optional(),
    allow_multiple: z.boolean().optional(),
    allow_notes: z.boolean().optional(),
});
export type QuestionPayload = z.infer<typeof questionPayloadSchema>;

// --- Discriminated union for payloadJson based on slide type ---
export const slidePayloadUnionSchema = z.discriminatedUnion("type", [
    questionPayloadSchema.extend({ type: z.literal("question") }),
    interludePayloadSchema.extend({ type: z.literal("interlude") }),
    // Assuming 'media' is for generic images for now
    z.object({ type: z.literal("media"), image_url: z.string().url(), alt_text: z.string().optional(), title: z.string().optional() }),
    videoMessagePayloadSchema.extend({ type: z.literal("video_message") }),
    audioMessagePayloadSchema.extend({ type: z.literal("audio_message") }),
]);
export type SlidePayloadUnion = z.infer<typeof slidePayloadUnionSchema>;


// --- Update InsertSlide schema ---
export const insertSlideSchema = createInsertSchema(slides, {
  packageId: z.string().uuid().nullable().optional(),
  type: z.enum(slideTypes),
  // Use z.custom for payloadJson if discriminated union is too complex for createInsertSchema,
  // or handle payload validation separately before insertion.
  // For direct use with createInsertSchema, ensuring payload matches 'type' is tricky.
  // Often, payloadJson is kept as z.any() here, and validation happens in application logic.
  // However, if you construct the payload object correctly typed before passing to insert, it's fine.
  payloadJson: z.custom<SlidePayloadUnion>((data) => {
    // Perform validation based on the type property if possible, or assume it's pre-validated.
    // This custom validation can be complex. For simplicity, one might use z.any()
    // and validate separately or trust the input structure.
    // For now, let's assume the input is structured correctly according to its type.
    return typeof data === 'object' && data !== null;
  }),
}).omit({
  id: true,
  createdAt: true
});

// ... (rest of your schema: sessions, participants, responses, etc.) ...

// Update Types
export type Slide = typeof slides.$inferSelect;
export type InsertSlide = z.infer<typeof insertSlideSchema>;
// ... (other types)
Key Changes:
slideTypes constant includes the new types.
slides.type in pgTable can use $type<typeof slideTypes[number]>() for better type inference with Drizzle, though the DB CHECK constraint is the ultimate enforcer.
Added videoMessagePayloadSchema and audioMessagePayloadSchema for Zod validation and type inference of the payload_json for these new types.
Important for insertSlideSchema.payloadJson: Using a Zod discriminated union is the most type-safe way but can be complex with createInsertSchema. An alternative is z.any() and ensuring your application logic (e.g., in storage.createSlide) validates/constructs the payload correctly according to the type. The example above shows a z.custom approach or implies pre-validated data. For the AI, focusing on the payload schemas (videoMessagePayloadSchema, audioMessagePayloadSchema) as the target structure is key.
2. Frontend: Render Video/Audio Slides (client/src/pages/TastingSession.tsx)

Action: Modify the renderSlideContent function to handle the new slide types.
TypeScript

// In client/src/pages/TastingSession.tsx
// Within the TastingSession component:

// Make sure Slide type is imported and payload types if you defined them
// import type { Slide, VideoMessagePayload, AudioMessagePayload, QuestionPayload, InterludePayload } from "@shared/schema";

const renderSlideContent = (slide: Slide) => {
  // Use a type assertion or, ideally, parse with your Zod discriminated union if defined
  const payload = slide.payloadJson as any; // Simpler for now, but could be: slidePayloadUnionSchema.parse(slide.payloadJson)

  // ... (existing cases for 'interlude' and 'question') ...

  if (slide.type === 'interlude') {
    const interludeData = payload as InterludePayload; // Assuming InterludePayload type
    return (
      <motion.div /* existing animation props */
        className="text-center space-y-6 bg-gradient-card backdrop-blur-xl rounded-3xl p-6 md:p-8 border border-white/20 shadow-xl"
      >
        {interludeData.wine_image && (
          <div className="mb-6 md:mb-8">
            <img
              src={interludeData.wine_image}
              alt={interludeData.wine_name || "Wine"}
              className="w-40 h-60 md:w-48 md:h-72 mx-auto rounded-2xl shadow-2xl object-cover border-2 border-white/10"
            />
          </div>
        )}
        <h2 className="text-2xl md:text-3xl font-bold text-white mb-2 md:mb-3">{interludeData.title}</h2>
        {interludeData.wine_name && (
          <h3 className="text-lg md:text-xl text-purple-200 mb-3 md:mb-4">{interludeData.wine_name}</h3>
        )}
        {interludeData.description && <p className="text-white/80 text-base md:text-lg">{interludeData.description}</p>}
      </motion.div>
    );
  }

  if (slide.type === 'question') {
    // Assuming renderQuestion correctly handles different question payloads
    return renderQuestion(slide);
  }

  // NEW: Handle 'video_message'
  if (slide.type === 'video_message') {
    const videoData = payload as VideoMessagePayload; // Assuming VideoMessagePayload type
    if (!videoData.video_url) return <div>Video URL missing for this slide.</div>;
    return (
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        className="space-y-4 bg-gradient-card backdrop-blur-xl rounded-3xl p-6 md:p-8 border border-white/20 shadow-xl"
      >
        {videoData.title && <h2 className="text-2xl md:text-3xl font-bold text-white text-center mb-3">{videoData.title}</h2>}
        {videoData.description && <p className="text-white/70 text-center mb-4">{videoData.description}</p>}
        <div className="aspect-video bg-black rounded-xl overflow-hidden shadow-lg mx-auto max-w-2xl">
          <video
            src={videoData.video_url}
            controls={videoData.show_controls !== undefined ? videoData.show_controls : true}
            autoPlay={videoData.autoplay || false}
            poster={videoData.poster_url}
            className="w-full h-full object-contain"
            playsInline // Important for mobile
          />
        </div>
      </motion.div>
    );
  }

  // NEW: Handle 'audio_message'
  if (slide.type === 'audio_message') {
    const audioData = payload as AudioMessagePayload; // Assuming AudioMessagePayload type
    if (!audioData.audio_url) return <div>Audio URL missing for this slide.</div>;
    return (
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        className="space-y-4 bg-gradient-card backdrop-blur-xl rounded-3xl p-6 md:p-8 border border-white/20 shadow-xl"
      >
        {audioData.title && <h2 className="text-2xl md:text-3xl font-bold text-white text-center mb-3">{audioData.title}</h2>}
        {audioData.description && <p className="text-white/70 text-center mb-4">{audioData.description}</p>}
        <audio
          src={audioData.audio_url}
          controls={audioData.show_controls !== undefined ? audioData.show_controls : true}
          autoPlay={audioData.autoplay || false}
          className="w-full max-w-md mx-auto rounded-lg"
        />
      </motion.div>
    );
  }

  // Fallback for other 'media' types or unknown types (if 'media' is for simple images)
  if (slide.type === 'media' && payload.image_url) {
     return (
        <motion.div className="text-center bg-gradient-card backdrop-blur-xl rounded-3xl p-6 md:p-8 border border-white/20 shadow-xl">
          {payload.title && <h2 className="text-2xl md:text-3xl font-bold text-white mb-4">{payload.title}</h2>}
          <img src={payload.image_url} alt={payload.alt_text || 'Media content'} className="w-full max-w-md mx-auto rounded-lg shadow-lg"/>
        </motion.div>
      );
  }

  console.warn("Unsupported slide type or missing media URL for slide:", slide);
  return <div className="text-white text-center p-4">Unsupported slide type: {slide.type} or missing media content.</div>;
};
Styling: Ensure the video/audio players are styled appropriately to fit your design (e.g., w-full, rounded-lg, aspect-video for video).
playsInline is important for videos on iOS.
3. Backend: Example Slide Creation in server/storage.ts (for demonstration)

Action: Modify the initializeWineTastingData function in DatabaseStorage class to include an example of creating a 'video_message' slide. This serves as a reference for how the payload_json should be structured. The user will replace the placeholder URL with their actual Supabase Storage URL.

TypeScript

// In server/storage.ts, within DatabaseStorage class, inside initializeWineTastingData method:
// Add this after creating other slides for the bordeauxPackage

// ... (after existing slide creations for bordeauxPackage) ...
if (bordeauxPackage) { // Ensure bordeauxPackage was successfully created/fetched
  await this.createSlide({
    packageId: bordeauxPackage.id,
    position: 9, // Or determine dynamically as the next position
    type: "video_message", // New slide type
    payloadJson: { // Example payload structure
      title: "Sommelier's Welcome",
      description: "A brief introduction to this tasting experience by our expert sommelier.",
      // IMPORTANT: This URL will be replaced by the user with their actual public URL from Supabase Storage
      video_url: "PLACEHOLDER_VIDEO_URL_FROM_SUPABASE_STORAGE.mp4",
      poster_url: "PLACEHOLDER_POSTER_IMAGE_URL.jpg", // Optional
      show_controls: true,
      autoplay: false
    } as VideoMessagePayload // Type assertion for clarity
  });
  console.log("Example video message slide added to WINE01 package.");
}
// ...