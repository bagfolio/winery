Master Prompt: The "10/10" Platform Overhaul
The Big Picture: From Prototype to Professional Platform
Our current application is a prototype with several critical bugs and incomplete features. The goal of this session is to execute a comprehensive overhaul, transforming the disjointed editing experience into a professional, Kahoot-like Package Editor. We will fix all identified data flow issues, consolidate redundant code, and build out the full editor UI, complete with advanced functionality.
Our Strategic Plan:
Code Consolidation & Cleanup: We will start by eliminating duplicate files to create a single source of truth for our editor and core components. This is critical to prevent confusion and ensure we're building on a stable foundation.
Critical Data-Flow Fix: We will fix the most significant bug: the incorrect saving of slider/scale question data, which breaks all backend analytics.
Component Refactoring: We will standardize our UI by consolidating the multiple, redundant slider components into a single, reliable one.
Backend API Expansion: We will build the necessary API endpoints to support a fully-featured editor, including creating, updating, and deleting individual wines and slides within a package.
The Professional Editor UI: We will implement the full vision for the PackageEditor, including adding/editing wines, adding new slides from a template library, and a polished UI for managing question configurations.
Dashboard Integration & Polish: Finally, we will refine the SommelierDashboard to provide a clean, intuitive entry point into our new, powerful editor.
This is a full-stack operation. Let's execute this with precision.
Phase 0: De-duplication & Code Cleanup (CRITICAL FIRST STEP)
Our codebase has multiple files for the same feature. This must be fixed first. We will consolidate all editor logic into PackageEditor.tsx and standardize on ScaleQuestion.tsx.
<execute_bash>
We will use PackageEditor.tsx as the single source of truth.
rm client/src/pages/PackageEditorNew.tsx
rm client/src/pages/VideoEditorPackageEditor.tsx
rm client/src/pages/VideoEditorPackageEditorNew.tsx
We will use ScaleQuestion.tsx as the standard component.
rm client/src/components/questions/EnhancedScaleQuestion.tsx
</execute_bash>
Phase 1: Fix Critical Slider Data Flow & Analytics
Goal: Ensure scale question responses are saved as raw numbers so analytics work correctly.
1. Update client/src/pages/TastingSession.tsx
Modify handleAnswerChange to check if the answer is from a scale question. If so, save only the numeric value property, not the entire object.
// ... (imports)

export default function TastingSession() {
  // ... (keep all existing hooks and state)

  const handleAnswerChange = (slideId: string, answer: any, questionType?: string) => {
    let answerJson = answer;
    // CRITICAL FIX: If the question is a scale, we only want to store the numeric value
    // to ensure our analytics can aggregate it properly.
    if (questionType === 'scale' && typeof answer === 'object' && answer !== null && 'value' in answer) {
      answerJson = answer.value;
    } else if (questionType === 'scale' && typeof answer !== 'number') {
      // Handle the case where the initial value might be an object
      answerJson = answer?.value ?? answer;
    }

    // Save the potentially modified answer
    saveResponseMutation.mutate({ slideId, answerJson });

    setAnswers((prev) => {
      const newAnswers = { ...prev, [slideId]: answerJson };
      
      // Save progress to localStorage
      try {
        const sessionProgress = {
          answers: newAnswers,
          currentSlideIndex,
          lastUpdatedAt: Date.now(),
        };
        localStorage.setItem(`session_progress_${sessionId}_${participantId}`, JSON.stringify(sessionProgress));
      } catch (e) {
        console.warn("Could not save session progress to localStorage", e);
      }
      
      return newAnswers;
    });
  };

  // ... (keep the rest of the file, including the return statement)
  // Inside the render logic, when rendering a ScaleQuestion, ensure its 'type' is passed to handleAnswerChange
  // Example change within the return jsx:
  
  // Find this part:
  // if (slide.type === "question" && (slide.payloadJson as any).scale_min !== undefined) { ... }
  
  // And ensure the onChange prop looks like this:
  // onChange={(value) => handleAnswerChange(slide.id, { value }, 'scale')}
}
Use code with caution.
Typescript:client/src/pages/TastingSession.tsx
2. Update server/storage.ts
Modify getAggregatedSessionAnalytics to be robust. It must handle both the old object format ({ "value": 7 }) and the new numeric format (7) for backwards compatibility during the transition.
// ... (within the DatabaseStorage class)

  async getAggregatedSessionAnalytics(sessionId: string): Promise<any> {
    // ... (keep existing code for fetching session, participants, slides, etc.)
    // ... down to the "Process slide-by-slide analytics" loop ...

    for (const slide of questionSlides) {
      // ... (keep existing setup code inside the loop)

      if (slidePayload.question_type === "scale") {
        const scores = slideResponses
          .map((response) => {
            const answerData = response.answerJson as any;
            // ROBUSTNESS FIX: Handle both numeric and object-based scale answers
            if (typeof answerData === "number") {
              return answerData;
            }
            if (typeof answerData === "object" && answerData !== null && typeof answerData.value === "number") {
              return answerData.value;
            }
            return null;
          })
          .filter((score): score is number => score !== null); // Type guard to ensure we have an array of numbers
        
        // ... (the rest of the scale aggregation logic remains the same)
      }

      // ... (keep the rest of the function)
    }

    // ... (keep the final return statement)
  }

// ... (keep the rest of the file)
Use code with caution.
Typescript:server/storage.ts
Phase 2: Component & API Enhancement for the Editor
Goal: Create the necessary backend support and frontend components for a fully interactive editor.
1. Create client/src/lib/wineTemplates.ts
We need a centralized place for our slide templates to support the "Add Slide" feature.
import { HelpCircle, Clapperboard, Video, Music, Image as ImageIcon } from "lucide-react";

export const SLIDE_TEMPLATES = [
  {
    type: 'interlude',
    name: 'Interlude',
    icon: <Clapperboard className="w-4 h-4" />,
    description: 'A transition or informational slide.',
    defaultPayload: {
      title: 'New Interlude',
      description: 'A brief pause in the tasting experience.',
      duration: 30
    }
  },
  {
    type: 'question',
    name: 'Multiple Choice',
    icon: <HelpCircle className="w-4 h-4" />,
    description: 'Ask a question with several options.',
    defaultPayload: {
      title: 'New Question',
      question_type: 'multiple_choice',
      category: 'General',
      options: [{ id: '1', text: 'Option A' }],
      allow_multiple: false,
      allow_notes: true
    }
  },
  {
    type: 'question',
    name: 'Scale Rating',
    icon: <BarChart3 className="w-4 h-4" />,
    description: 'Ask for a rating on a numeric scale.',
    defaultPayload: {
      title: 'New Scale Question',
      question_type: 'scale',
      category: 'Rating',
      scale_min: 1,
      scale_max: 10,
      scale_labels: ['Low', 'High']
    }
  },
  {
    type: 'video_message',
    name: 'Video Message',
    icon: <Video className="w-4 h-4" />,
    description: 'Embed a video message.',
    defaultPayload: {
      title: 'Video Message',
      description: 'A video from your sommelier.',
      video_url: ''
    }
  },
];
Use code with caution.
Typescript:client/src/lib/wineTemplates.ts
2. Enhance Backend - server/routes.ts
Add new API endpoints for creating, updating, and deleting wines and slides.
// ... (keep existing imports)
import { 
  // ... other imports
  insertPackageWineSchema, 
  insertSlideSchema 
} from "@shared/schema";

export async function registerRoutes(app: express.Express) {
  // ... (keep existing routes)

  // --- WINE MANAGEMENT ENDPOINTS ---
  app.post('/api/packages/:packageId/wines', async (req, res) => {
    try {
      const { packageId } = req.params;
      const wineData = insertPackageWineSchema.parse({ ...req.body, packageId });
      const newWine = await storage.createPackageWineFromDashboard(wineData); // Assuming this function exists and works
      res.status(201).json(newWine);
    } catch (error) {
      console.error("Error creating wine:", error);
      res.status(500).json({ message: "Failed to create wine" });
    }
  });

  app.patch('/api/wines/:wineId', async (req, res) => {
    try {
      const { wineId } = req.params;
      const updatedWine = await storage.updatePackageWine(wineId, req.body);
      res.json(updatedWine);
    } catch (error) {
      console.error("Error updating wine:", error);
      res.status(500).json({ message: "Failed to update wine" });
    }
  });

  app.delete('/api/wines/:wineId', async (req, res) => {
    try {
      const { wineId } = req.params;
      await storage.deletePackageWine(wineId);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting wine:", error);
      res.status(500).json({ message: "Failed to delete wine" });
    }
  });

  // --- SLIDE MANAGEMENT ENDPOINTS ---
  app.post('/api/slides', async (req, res) => {
    try {
        const slideData = insertSlideSchema.parse(req.body);
        const newSlide = await storage.createSlide(slideData);
        res.status(201).json(newSlide);
    } catch (error) {
        console.error("Error creating slide:", error);
        res.status(500).json({ message: "Failed to create slide" });
    }
  });

  app.patch('/api/slides/:slideId', async (req, res) => {
    try {
      const { slideId } = req.params;
      const updatedSlide = await storage.updateSlide(slideId, req.body);
      res.json(updatedSlide);
    } catch (error) {
      console.error("Error updating slide:", error);
      res.status(500).json({ message: "Failed to update slide" });
    }
  });

  app.delete('/api/slides/:slideId', async (req, res) => {
    try {
      const { slideId } = req.params;
      await storage.deleteSlide(slideId);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting slide:", error);
      res.status(500).json({ message: "Failed to delete slide" });
    }
  });

  return server;
}
Use code with caution.
Typescript:server/routes.ts
Phase 3: Building the Professional Editor UI
Now we implement the full editor experience in PackageEditor.tsx and its child components.
1. Update client/src/pages/PackageEditor.tsx
This is the main orchestration component. It will manage state and pass props down to the three panels.
import { useState, useEffect } from 'react';
import { useParams, Link } from 'wouter';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { DndContext, closestCenter, PointerSensor, useSensor, useSensors, DragEndEvent } from '@dnd-kit/core';
import { arrayMove, SortableContext, verticalListSortingStrategy } from '@dnd-kit/sortable';
import { Button } from '@/components/ui/button';
import { LoadingOverlay } from '@/components/ui/loading-overlay';
import { ResizableHandle, ResizablePanel, ResizablePanelGroup } from "@/components/ui/resizable";
import { useToast } from '@/hooks/use-toast';
import { apiRequest } from '@/lib/queryClient';
import { SlideListPanel } from '@/components/editor/SlideListPanel';
import { SlidePreviewPanel } from '@/components/editor/SlidePreviewPanel';
import { SlideConfigPanel } from '@/components/editor/SlideConfigPanel';
import { Home, Save, PlusCircle, Edit } from 'lucide-react';
import type { Package, PackageWine, Slide } from "@shared/schema";
import { WineModal } from '@/components/WineModal'; // We will create/update this

type EditorData = Package & { wines: PackageWine[]; slides: Slide[] };

export default function PackageEditor() {
    const { code } = useParams<{ code: string }>();
    const queryClient = useQueryClient();
    const { toast } = useToast();

    const [wines, setWines] = useState<PackageWine[]>([]);
    const [slides, setSlides] = useState<Slide[]>([]);
    const [activeSlideId, setActiveSlideId] = useState<string | null>(null);
    const [isWineModalOpen, setIsWineModalOpen] = useState(false);
    const [editingWine, setEditingWine] = useState<PackageWine | null>(null);

    const { data: editorData, isLoading, error } = useQuery<EditorData>({
        queryKey: [`/api/packages/${code}/editor`],
        enabled: !!code,
    });

    useEffect(() => {
        if (editorData) {
            const sortedWines = [...editorData.wines].sort((a, b) => a.position - b.position);
            setWines(sortedWines);
            setSlides(editorData.slides);
            if (!activeSlideId && editorData.slides.length > 0) {
                setActiveSlideId(editorData.slides[0].id);
            }
        }
    }, [editorData, activeSlideId]);

    // Mutations (save order, update slide, CRUD for wines)
    // ... (keep useMutation hooks from previous step, and add new ones for wine CRUD)

    const handleDragEnd = (event: DragEndEvent) => {
      // ... (keep existing drag and drop logic)
    };

    const handleSave = () => {
        // ... (implement mutation call for saving slide order)
    };

    const handleOpenWineModal = (wine: PackageWine | null) => {
        setEditingWine(wine);
        setIsWineModalOpen(true);
    };

    const handleSaveWine = async (wineData: any) => {
        // ... (implement logic for creating/updating wine via mutation)
        setIsWineModalOpen(false);
    };
    
    const handleDeleteWine = async (wineId: string) => {
        // ... (implement logic for deleting wine via mutation)
    }

    const activeSlide = slides.find(s => s.id === activeSlideId);

    if (isLoading) return <LoadingOverlay isVisible={true} message="Loading Editor..." />;
    if (error) return <div>Error loading editor.</div>;

    return (
        <DndContext sensors={useSensors(useSensor(PointerSensor))} onDragEnd={handleDragEnd}>
            <div className="h-screen w-screen bg-gray-900 text-white flex flex-col overflow-hidden">
                <header> {/* ... Header with Save button ... */} </header>
                <ResizablePanelGroup direction="horizontal" className="flex-grow">
                    <ResizablePanel defaultSize={25} minSize={20}>
                        <SlideListPanel
                            wines={wines}
                            slides={slides}
                            activeSlideId={activeSlideId}
                            onSlideClick={setActiveSlideId}
                            onAddWine={() => handleOpenWineModal(null)}
                            onEditWine={handleOpenWineModal}
                        />
                    </ResizablePanel>
                    <ResizableHandle withHandle />
                    <ResizablePanel defaultSize={50} minSize={30}>
                        <SlidePreviewPanel activeSlide={activeSlide} />
                    </ResizablePanel>
                    <ResizableHandle withHandle />
                    <ResizablePanel defaultSize={25} minSize={20}>
                        <SlideConfigPanel
                            activeSlide={activeSlide}
                            onSlideUpdate={(slideId, payload) => {
                                // updateSlide.mutate({ slideId, payload })
                            }}
                        />
                    </ResizablePanel>
                </ResizablePanelGroup>
            </div>
            {isWineModalOpen && (
                <WineModal
                    isOpen={isWineModalOpen}
                    onClose={() => setIsWineModalOpen(false)}
                    wine={editingWine}
                    packageId={editorData!.id}
                    onSave={handleSaveWine}
                />
            )}
        </DndContext>
    );
}
Use code with caution.
Typescript:client/src/pages/PackageEditor.tsx
2. Update client/src/components/editor/SlideListPanel.tsx
Add buttons for adding and editing wines.
// ... (imports)
import { Button } from '@/components/ui/button';
import { PlusCircle, Edit } from 'lucide-react';

// ... (SortableSlideItem component remains the same)

export function SlideListPanel({ wines, slides, activeSlideId, onSlideClick, onAddWine, onEditWine }: {
    wines: PackageWine[];
    slides: Slide[];
    activeSlideId: string | null;
    onSlideClick: (id: string) => void;
    onAddWine: () => void;
    onEditWine: (wine: PackageWine) => void;
}) {
    // Group slides by wine ID
    const slidesByWine = slides.reduce((acc, slide) => {
        (acc[slide.packageWineId] = acc[slide.packageWineId] || []).push(slide);
        return acc;
    }, {} as Record<string, Slide[]>);

    return (
        <div className="h-full bg-gray-800/50 p-2 overflow-y-auto">
            <div className="flex justify-between items-center p-2">
                <h2 className="font-bold text-white">Wines & Slides</h2>
                <Button size="sm" variant="ghost" onClick={onAddWine} className="text-purple-300 hover:text-white">
                    <PlusCircle className="w-4 h-4 mr-2" /> Add Wine
                </Button>
            </div>
            <div className="space-y-4 p-2">
                {wines.map(wine => {
                    const wineSlides = (slidesByWine[wine.id] || []).sort((a,b) => a.position - b.position);
                    return (
                        <div key={wine.id}>
                            <div className="flex justify-between items-center mb-2">
                                <h3 className="text-lg font-bold text-purple-300">{wine.wineName}</h3>
                                <Button size="icon" variant="ghost" onClick={() => onEditWine(wine)} className="h-6 w-6 text-gray-400 hover:text-white">
                                    <Edit className="w-3 h-3" />
                                </Button>
                            </div>
                            <SortableContext items={wineSlides.map(s => s.id)} strategy={verticalListSortingStrategy}>
                                {wineSlides.map(slide => (
                                    <SortableSlideItem
                                        key={slide.id}
                                        slide={slide}
                                        isActive={slide.id === activeSlideId}
                                        onClick={() => onSlideClick(slide.id)}
                                    />
                                ))}
                            </SortableContext>
                        </div>
                    );
                })}
            </div>
        </div>
    );
}
Use code with caution.
Typescript:client/src/components/editor/SlideListPanel.tsx
3. Update client/src/components/WineModal.tsx
Make the wine management modal taller and ensure the save/close buttons are always visible by putting them in a fixed footer.
// ... (imports)
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from '@/components/ui/dialog';

export function WineModal({ isOpen, onClose, wine, packageId, onSave }: {
    isOpen: boolean;
    onClose: () => void;
    wine: PackageWine | null;
    packageId: string;
    onSave: (data: any) => void;
}) {
    // ... (keep all form state and logic)

    return (
        <Dialog open={isOpen} onOpenChange={onClose}>
            <DialogContent className="max-w-4xl h-[90vh] flex flex-col bg-gradient-card border-white/20 text-white">
                <DialogHeader>
                    <DialogTitle>{wine ? 'Edit Wine' : 'Add New Wine'}</DialogTitle>
                </DialogHeader>
                <div className="flex-grow overflow-y-auto pr-6 -mr-6">
                    {/* All form content from previous step goes here */}
                    {/* e.g., <Tabs>...</Tabs> */}
                </div>
                <DialogFooter className="pt-4 border-t border-white/10">
                    <Button variant="ghost" onClick={onClose}>Cancel</Button>
                    <Button onClick={handleSubmit}>
                        <Save className="mr-2 h-4 w-4" />
                        {wine ? 'Save Changes' : 'Add Wine'}
                    </Button>
                </DialogFooter>
            </DialogContent>
        </Dialog>
    );
}
Use code with caution.
Typescript:client/src/components/WineModal.tsx
4. Dashboard UI Cleanup - client/src/pages/SommelierDashboard.tsx
Consolidate the actions into a single DropdownMenu for a cleaner interface.
// ... (imports)
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "@/components/ui/dropdown-menu";
import { MoreHorizontal, Edit, Settings, Trash } from "lucide-react";

export default function SommelierDashboard() {
  // ... (useQuery hook remains the same)

  return (
      // ... (outer divs)
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {packages.map((pkg) => (
            <Card key={pkg.id} className="...">
              {/* ... CardHeader and CardContent ... */}
              <CardFooter className="flex justify-between">
                <Badge>{pkg.code}</Badge>
                <DropdownMenu>
                    <DropdownMenuTrigger asChild>
                        <Button variant="ghost" size="icon" className="h-8 w-8">
                            <MoreHorizontal className="h-4 w-4" />
                        </Button>
                    </DropdownMenuTrigger>
                    <DropdownMenuContent align="end">
                        <DropdownMenuItem onSelect={() => setLocation(`/editor/${pkg.code}`)}>
                            <Edit className="mr-2 h-4 w-4" />
                            <span>Edit Package</span>
                        </DropdownMenuItem>
                        <DropdownMenuItem>
                            <Settings className="mr-2 h-4 w-4" />
                            <span>Settings</span>
                        </DropdownMenuItem>
                        <DropdownMenuItem className="text-red-400">
                            <Trash className="mr-2 h-4 w-4" />
                            <span>Delete</span>
                        </DropdownMenuItem>
                    </DropdownMenuContent>
                </DropdownMenu>
              </CardFooter>
            </Card>
          ))}
        </div>
      // ... (closing divs)
  );
}
Use code with caution.
Typescript:client/src/pages/SommelierDashboard.tsx
This comprehensive set of instructions will guide the AI to fix critical bugs, refactor the codebase for clarity, and build out the professional-grade editor as envisioned in the roadmap, delivering a true "10/10" feature.