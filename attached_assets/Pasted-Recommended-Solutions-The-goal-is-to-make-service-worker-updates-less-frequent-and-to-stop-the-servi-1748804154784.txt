Recommended Solutions
The goal is to make service worker updates less frequent and to stop the service worker from interfering with application data stored in IndexedDB.

1. Stop Service Worker from Deleting IndexedDB
This is the most critical change. The service worker should manage its own caches, not application databases.

File: client/public/service-worker.js

Action: In the activate event listener, remove the block of code responsible for deleting KnowYourGrapeDB.

JavaScript

// Inside self.addEventListener("activate", (event) => { ... event.waitUntil(Promise.all([ ... ])); ... });

// REMOVE THIS ENTIRE BLOCK:
// new Promise((resolve) => {
//   const deleteReq = indexedDB.deleteDatabase('KnowYourGrapeDB');
//   deleteReq.onsuccess = () => {
//     console.log("[Service Worker] Cleared IndexedDB for fresh start");
//     resolve();
//   };
//   deleteReq.onerror = () => {
//     console.log("[Service Worker] Could not clear IndexedDB");
//     resolve();
//   };
// })
Your activate event should still clean up old service worker caches (those starting with CACHE_PREFIX), but it should not touch IndexedDB.

2. Stabilize Service Worker Registration
Prevent the service worker from being treated as "new" on every page load.

File: client/src/main.tsx

Action: Modify the service worker registration to remove the timestamp. The browser will then handle updates by checking if the service-worker.js file has actually changed.

JavaScript

// Change FROM:
// const timestamp = Date.now();
// const registration = await navigator.serviceWorker.register(`/service-worker.js?v=${timestamp}`);

// Change TO:
const registration = await navigator.serviceWorker.register('/service-worker.js');
3. Re-evaluate Aggressive Chrome Cache Clearing
The Chrome-specific cache and service worker unregistration logic in client/src/main.tsx might be too aggressive now and could potentially be removed or toned down. It was likely implemented to solve a specific stubborn caching issue. With the changes above, the service worker update cycle will be much more stable.

File: client/src/main.tsx

Recommendation: Comment out or remove the following blocks to see if the primary fixes are sufficient:

The block checking sessionStorage.getItem('chrome-cache-v1.4.0'):

JavaScript

// if (navigator.userAgent.includes('Chrome')) {
//   const hasCleared = sessionStorage.getItem('chrome-cache-v1.4.0');
//   if (!hasCleared) {
//     sessionStorage.setItem('chrome-cache-v1.4.0', 'true');
//     caches.keys().then(names => {
//       names.forEach(name => caches.delete(name));
//     });
//   }
// }
And the block within window.addEventListener('load', async () => { ... }):

JavaScript

// if (navigator.userAgent.includes('Chrome')) {
//   // Clear all caches first
//   const cacheNames = await caches.keys();
//   await Promise.all(cacheNames.map(name => caches.delete(name)));

//   // Unregister existing service workers
//   const registrations = await navigator.serviceWorker.getRegistrations();
//   await Promise.all(registrations.map(reg => reg.unregister()));

//   // Wait a moment for cleanup
//   await new Promise(resolve => setTimeout(resolve, 100));
// }
Why These Changes Should Help:
Data Preservation: Your session data in IndexedDB (KnowYourGrapeDB) will no longer be deleted every time the service worker updates. This is crucial for allowing users to rejoin sessions.
Stable Updates: The service worker will only update when the actual service-worker.js file changes on the server, not on every app load. This reduces unnecessary churn.
Reduced Complexity: Removing redundant and conflicting cache-clearing logic simplifies the overall caching strategy.
The useSessionPersistence hook itself seems well-structured for handling offline data and syncing. Its main issue was the external deletion of its database.