n the redesigned client/src/pages/Gateway.tsx, the "Host a New Tasting" path uses createSessionMutation to initiate a new session. However, this mutation currently only makes a POST request to /api/sessions (which creates a session entity) and then tries to navigate to /host/${sessionData.sessionId}/${sessionData.hostParticipantId}.

There are two issues:

The createSessionMutation (and the /api/sessions endpoint it calls) does not currently create a participant record for the host or associate them with the new session with isHost: true.
The data returned from POST /api/sessions is just the session object, so sessionData.hostParticipantId will be undefined, breaking navigation.
This flow needs to be corrected so that when a host initiates a session, the session is created, the host is added as the first participant (marked as host), and the client receives both the sessionId and the host's participantId for correct navigation.

Objective (What):
Refactor the host session creation logic initiated from Gateway.tsx to ensure that:

A new session is created for the specified package code.
The user initiating this flow is added as a participant to this new session with isHost: true.
Both the new sessionId and the host's participantId are made available to the frontend for navigation to /host/:sessionId/:participantId.
Implementation Details (How):

Option 1 (Preferred: Enhance Backend POST /api/sessions or Create New Endpoint):

Modify POST /api/sessions in server/routes.ts (and corresponding storage.createSession or a new service method):
The endpoint should optionally accept host details (e.g., displayName, email if collected, though Gateway.tsx currently only sends packageCode and a hardcoded hostName to the mutation). For now, a default display name like "Host" for the participant record is acceptable.
After creating the session in storage.createSession, the logic should immediately call storage.createParticipant to add a participant with isHost: true to this new session.
The API endpoint should then return an object containing both the session details (including sessionId) AND the newly created host participantId.
TypeScript

// Example of modified response from POST /api/sessions
// res.json({ session: newSessionData, hostParticipantId: newHostParticipant.id });
Update createSessionMutation in Gateway.tsx:
Modify its mutationFn to expect this new response structure.
The onSuccess callback will then have both sessionData.session.id (for sessionId) and sessionData.hostParticipantId for navigation.
Option 2 (Alternative: Client-Side Orchestration - more prone to partial failure):

Keep POST /api/sessions as is (just creates a session and returns it).
In Gateway.tsx, after createSessionMutation.mutateAsync successfully returns the new sessionData:
Immediately make a second API call using a new mutation (e.g., addHostParticipantMutation) to POST /api/sessions/${sessionData.id}/participants.
The body of this second call would be { displayName: user?.displayName || 'Host', email: user?.email || '', isHost: true } (fetching displayName and email from useUserProfile if available, or using defaults).
Once this second mutation succeeds and returns the new host participantData, then navigate using sessionData.id and participantData.id.
This approach is less ideal as it involves two separate network requests and more complex state management on the client for a single logical operation.
Guidance for Replit AI:

Strongly prefer Option 1 (Enhance Backend). This makes the host session initiation more atomic and robust.
The createSessionMutation in Gateway.tsx currently sends hostName: 'Host' in the body to /api/sessions. This is not used by the backend. It should instead send data that can be used to create the host participant (e.g., if you want to collect host name from useUserProfile first, or default to "Host").
The server/routes.ts for POST /api/sessions currently gets packageId from (pkg as any).id. Ensure this remains correct. The pkg is looked up using packageCode.
Acceptance Criteria:

When a user triggers the "Host a New Tasting" flow from Gateway.tsx with a valid packageCode:
A new session record is created in the sessions table, linked to the correct package.
A new participant record is created in the participants table, linked to the new session, with isHost set to true.
The frontend createSessionMutation receives both the sessionId and the host's participantId.
The user is correctly navigated to /host/:sessionId/:hostParticipantId.
The process is robust and handles potential errors (e.g., invalid package code).
