Of course. This is a complex but exciting challenge. The goal is to transform a "2/10" feature into a "10/10" professional-grade experience. A simple patch won't do; we need a complete architectural and UX overhaul of the content management system.

Here is a meticulously crafted, genius-level prompt designed to guide the Replit AI through this transformation. It's broken down into logical, iterative steps, starting with the backend foundation and culminating in a polished, feature-complete UI.

Prompt for Replit AI

The Big Picture: From "Broken Modal" to "Professional Package Editor"

Our current editing functionality is severely lacking. It's a "2/10" experience trapped in a tiny, unusable modal. Our goal is to scrap that and build a professional, full-screen Package Editor that is powerful, intuitive, and feels like a specialized tool like Kahoot's editor. We will also fix related UI bugs and improve data seeding to create a seamless end-to-end experience for sommeliers.

Our High-Level Plan:

Backend & Data Foundation: We'll start by seeding the database with a realistic multi-wine package and create the necessary API endpoints to fetch, update, and reorder all package content (wines and slides).

The New Editor Page: We will create a new, dedicated route and page (/editor/:packageCode) to house the editor.

Professional Editor Layout: We'll use a three-panel, resizable layout for the editor: a slide list on the left, a live preview in the center, and a configuration panel on the right.

Core Functionality: We will implement the logic to fetch all data for a package and display the slides grouped by their respective wines in the slide list.

Drag-and-Drop Reordering: We'll implement intuitive drag-and-drop functionality for reordering slides both within a wine and between wines.

Dynamic Slide Configuration: We'll make the configuration panel on the right context-aware, showing the correct form to edit the content of any selected slide.

Wine Management: We'll add a modal to allow sommeliers to add, edit, and delete wines within the package directly from the editor.

Final Polish: We will fix the broken wine dropdown on the Sommelier Dashboard and add a clear "Edit" button to navigate to our new editor.

Let's begin the implementation.

Pre-computation Step: Install Dependencies

First, we need to install the libraries required for drag-and-drop functionality.

<execute_bash>
npm i @dnd-kit/core @dnd-kit/sortable
</execute_bash>

Phase 1: Backend Foundation & Data Seeding

We need robust data and APIs before we can build the frontend.

Goal: Update the data seeding to create a multi-wine package and create the API endpoints needed for the editor.

1. Update server/storage.ts

We must rewrite initializeWineTastingData to create a realistic package with multiple wines and slides. We also need new functions to get all data for the editor and to update the slide order.

import { db } from "./db";
import {
  packages,
  packageWines,
  slides,
  sessions,
  participants,
  responses,
  glossaryTerms,
  type InsertPackage,
  type InsertPackageWine,
  type InsertSlide,
  type InsertSession,
  type InsertParticipant,
  type InsertResponse,
  type InsertGlossaryTerm,
  type Package,
  type PackageWine,
  type Slide,
  type Session,
  type Participant,
  type Response,
  type GlossaryTerm,
} from "@shared/schema";
import { eq, and, asc, inArray } from "drizzle-orm";
import { alias }from "drizzle-orm/pg-core";

// --- Keep all existing functions up to this point ---

// NEW: Get all packages with their associated wines for the dashboard
export async function getAllPackagesWithWines(): Promise<(Package & { wines: PackageWine[] })[]> {
  const allPackages = await db.select().from(packages).orderBy(asc(packages.createdAt));
  if (allPackages.length === 0) return [];

  const packageIds = allPackages.map(p => p.id);
  const allPackageWines = await db.select().from(packageWines)
    .where(inArray(packageWines.packageId, packageIds))
    .orderBy(asc(packageWines.position));

  return allPackages.map(pkg => ({
    ...pkg,
    wines: allPackageWines.filter(wine => wine.packageId === pkg.id),
  }));
}

// NEW: Get a single package with all its wines and all their slides for the editor
export async function getPackageWithWinesAndSlides(packageCode: string) {
    const pkg = await getPackageByCode(packageCode);
    if (!pkg) {
        return null;
    }

    const wines = await getPackageWines(pkg.id);
    if (wines.length === 0) {
        return { ...pkg, wines: [], slides: [] };
    }

    const wineIds = wines.map(w => w.id);
    const allSlidesForPackage = await db.select()
        .from(slides)
        .where(inArray(slides.packageWineId, wineIds))
        .orderBy(asc(slides.position));

    return {
        ...pkg,
        wines,
        slides: allSlidesForPackage,
    };
}


// NEW: Update the order and wine assignment of multiple slides in a single transaction
export async function updateSlidesOrder(slideUpdates: { slideId: string; packageWineId: string; position: number }[]) {
  if (slideUpdates.length === 0) return;
  return db.transaction(async (tx) => {
    await Promise.all(slideUpdates.map(update =>
      tx.update(slides)
        .set({ packageWineId: update.packageWineId, position: update.position })
        .where(eq(slides.id, update.slideId))
    ));
  });
}


// --- Keep other functions: createSession, getSessionById, etc. ---

// REWRITTEN: Seeding logic for a proper multi-wine package
export async function initializeWineTastingData() {
  console.log("Seeding initial wine tasting data...");

  // Define slide templates to avoid repetition
  const slideTemplates = [
    {
      position: 1,
      type: "interlude",
      section_type: "intro",
      payloadJson: {
        title: "Welcome to the Tasting",
        description: "Let's begin our journey with this exceptional wine.",
      },
    },
    {
      position: 2,
      type: "question",
      section_type: "deep_dive",
      payloadJson: {
        title: "What aromas do you detect?",
        description: "Take a moment to swirl and smell. Select all the aromas you can identify.",
        category: "Aroma",
        allow_multiple: true,
        allow_notes: true,
        options: [
          { id: "aroma_dark_fruit", text: "Dark fruits (blackberry, plum)" },
          { id: "aroma_vanilla_oak", text: "Vanilla and oak" },
          { id: "aroma_spice", text: "Spices (pepper, clove)" },
        ],
      },
    },
    {
      position: 3,
      type: "question",
      section_type: "deep_dive",
      payloadJson: {
        title: "Rate the Aroma Intensity",
        description: "How strong are the aromas? 1 being very light, 10 being very intense.",
        category: "Intensity",
        type: "scale",
        scale_min: 1,
        scale_max: 10,
        scale_labels: ["Very Light", "Very Intense"],
      },
    },
  ];

  try {
    // 1. Create the main package
    let bordeauxPackage = await getPackageByCode("BORDEAUX");
    if (!bordeauxPackage) {
      bordeauxPackage = await createPackage({
        code: "BORDEAUX",
        name: "Bordeaux Discovery Collection",
        description: "A curated selection from the heart of French winemaking.",
      });
      console.log(`Created package: ${bordeauxPackage.name}`);
    } else {
        // If package exists, we assume it's seeded and skip the rest
        console.log("BORDEAUX package already exists. Skipping seeding.");
        return;
    }

    // 2. Create the wines for the package
    const winesToCreate = [
      {
        position: 1,
        wineName: "2018 Château Margaux",
        wineDescription: "A premier grand cru classé, known for its elegance and complexity.",
        wineImageUrl: "https://images.unsplash.com/photo-1553361371-9b22f78e8b1d?w=400",
      },
      {
        position: 2,
        wineName: "2019 Château Latour",
        wineDescription: "A powerhouse of Pauillac, famed for its structure and longevity.",
        wineImageUrl: "https://images.unsplash.com/photo-1584916201218-6e3a36923444?w=400",
      },
    ];

    const createdWines = [];
    for (const wine of winesToCreate) {
        const newWine = await createPackageWine({
            packageId: bordeauxPackage.id,
            ...wine,
        });
        createdWines.push(newWine);
        console.log(`Created wine: ${newWine.wineName}`);
    }

    // 3. Create slides for EACH wine
    for (const wine of createdWines) {
        for (const template of slideTemplates) {
            let payload = template.payloadJson;
            // Inject wine-specific info into the interlude slide
            if (template.type === 'interlude') {
                payload = {
                    ...payload,
                    wine_name: wine.wineName,
                    wine_image_url: wine.wineImageUrl,
                };
            }

            await createSlide({
                packageWineId: wine.id,
                position: template.position,
                type: template.type as any,
                section_type: template.section_type,
                payloadJson: payload,
            });
        }
        console.log(`Created ${slideTemplates.length} slides for ${wine.wineName}`);
    }

    console.log("Finished seeding data successfully.");
  } catch (error) {
    console.error("Error seeding wine tasting data:", error);
  }
}

// Ensure other functions like createPackage, getPackageByCode, etc., remain


2. Update server/routes.ts

We need to add the new API endpoints for the editor and for updating slide order.

import http from "http";
import express, { type Request, Response } from "express";
import {
  createPackage,
  getPackageByCode,
  createSession,
  getSessionById,
  addParticipantToSession,
  getParticipantById,
  getSlidesByPackageId,
  saveResponse,
  getResponsesByParticipant,
  initializeWineTastingData,
  getAllGlossaryTerms,
  getAllPackages,
  updateParticipantProgress,
  getAllPackagesWithWines, // Import new function
  getPackageWithWinesAndSlides, // Import new function
  updateSlidesOrder, // Import new function
} from "./storage";

export async function registerRoutes(app: express.Express) {
  const server = http.createServer(app);

  app.get("/api/seed-data", async (req, res) => {
    await initializeWineTastingData();
    res.status(200).send("Data seeded successfully!");
  });

  // ... (keep existing /api/glossary route)
  app.get("/api/glossary", async (req, res) => {
    const terms = await getAllGlossaryTerms();
    res.json(terms);
  });

  // UPDATED: Use new function to include wines
  app.get("/api/packages", async (req, res) => {
    const packages = await getAllPackagesWithWines();
    res.json(packages);
  });

  // NEW: Endpoint for the slide editor to get all package data
  app.get("/api/packages/:code/editor", async (req, res) => {
    const { code } = req.params;
    const data = await getPackageWithWinesAndSlides(code);
    if (!data) {
      return res.status(404).json({ message: "Package not found" });
    }
    res.json(data);
  });
  
  // ... (keep existing /api/packages/:code)

  // NEW: Endpoint to update slide order
  app.put("/api/slides/order", async (req, res) => {
    const { slideUpdates } = req.body;
    if (!Array.isArray(slideUpdates)) {
        return res.status(400).json({ message: "Invalid payload: slideUpdates must be an array." });
    }
    try {
        await updateSlidesOrder(slideUpdates);
        res.status(200).json({ message: "Slide order updated successfully." });
    } catch (error) {
        console.error("Failed to update slide order:", error);
        res.status(500).json({ message: "Failed to update slide order." });
    }
  });

  // ... (keep all other existing routes for sessions, participants, responses)

  return server;
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Typescript:server/routes.ts
IGNORE_WHEN_COPYING_END
Phase 2: Building the SlideEditor Page

Now we'll create the dedicated page and its structure.

1. Update client/src/App.tsx

Add the new route for the editor. I'll create the SlideEditor component next.

import { Switch, Route } from "wouter";
import { queryClient } from "./lib/queryClient";
import { QueryClientProvider } from "@tanstack/react-query";
import { Toaster } from "@/components/ui/toaster";
import { TooltipProvider } from "@/components/ui/tooltip";
import { GlossaryProvider } from "@/contexts/GlossaryContext";
import Gateway from "@/pages/Gateway";
import SessionJoin from "@/pages/SessionJoin";
import TastingSession from "@/pages/TastingSession";
import TastingCompletion from "@/pages/TastingCompletion";
import HostDashboard from "@/pages/HostDashboard";
import SommelierDashboard from "@/pages/SommelierDashboard";
import Profile from "@/pages/Profile";
import NotFound from "@/pages/not-found";
import SlideEditor from "@/pages/SlideEditor"; // Import the new page

function Router() {
  return (
    <Switch>
      <Route path="/" component={Gateway} />
      <Route path="/sommelier" component={SommelierDashboard} />
      <Route path="/editor/:packageCode" component={SlideEditor} /> {/* Add new route */}
      <Route path="/profile" component={Profile} />
      <Route path="/join" component={SessionJoin} />
      // ... (rest of the routes)
    </Switch>
  );
}

function App() {
  // ... (no changes here)
}

export default App;
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Typescript:client/src/App.tsx
IGNORE_WHEN_COPYING_END

2. Create client/src/pages/SlideEditor.tsx

This is the main file for our new editor. I'll set up the three-panel layout using shadcn's Resizable components and fetch the data.

import { useState, useEffect } from "react";
import { useParams, Link } from "wouter";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { DndContext, closestCenter, PointerSensor, useSensor, useSensors } from '@dnd-kit/core';
import { SortableContext, verticalListSortingStrategy, arrayMove } from '@dnd-kit/sortable';

import { apiRequest } from "@/lib/queryClient";
import { LoadingOverlay } from "@/components/ui/loading-overlay";
import { Button } from "@/components/ui/button";
import { ResizableHandle, ResizablePanel, ResizablePanelGroup } from "@/components/ui/resizable";
import { Home, GripVertical } from "lucide-react";

import type { Package, PackageWine, Slide } from "@shared/schema";

// We will create these components in the next steps
// import { SlideListPanel } from '@/components/editor/SlideListPanel';
// import { SlidePreviewPanel } from '@/components/editor/SlidePreviewPanel';
// import { SlideConfigPanel } from '@/components/editor/SlideConfigPanel';

type EditorData = Package & { wines: PackageWine[]; slides: Slide[] };

export default function SlideEditor() {
    const { packageCode } = useParams();
    const queryClient = useQueryClient();

    const { data: editorData, isLoading, error } = useQuery<EditorData>({
        queryKey: [`/api/packages/${packageCode}/editor`],
        enabled: !!packageCode,
    });

    const [activeSlideId, setActiveSlideId] = useState<string | null>(null);

    const activeSlide = editorData?.slides.find(s => s.id === activeSlideId);

    if (isLoading) {
        return <LoadingOverlay isVisible={true} message="Loading Editor..." />;
    }

    if (error) {
        return (
            <div className="min-h-screen bg-gradient-primary text-white flex flex-col items-center justify-center">
                <h2 className="text-2xl font-bold mb-4">Error Loading Editor</h2>
                <p className="text-red-400 mb-6">{(error as Error).message}</p>
                <Link href="/sommelier">
                    <Button variant="outline">
                        <Home className="mr-2 h-4 w-4" /> Go back to Dashboard
                    </Button>
                </Link>
            </div>
        );
    }

    if (!editorData) {
        return (
            <div className="min-h-screen bg-gradient-primary text-white flex flex-col items-center justify-center">
                <h2 className="text-2xl font-bold mb-4">Package Not Found</h2>
                <p className="mb-6">The package with code "{packageCode}" could not be found.</p>
                 <Link href="/sommelier">
                    <Button variant="outline">
                        <Home className="mr-2 h-4 w-4" /> Go back to Dashboard
                    </Button>
                </Link>
            </div>
        );
    }

    return (
        <div className="h-screen w-screen bg-gray-900 text-white flex flex-col overflow-hidden">
            {/* Header */}
            <header className="flex-shrink-0 bg-gray-800 border-b border-gray-700 px-4 py-2 flex items-center justify-between">
                <div className="flex items-center gap-4">
                     <Link href="/sommelier">
                        <Button variant="ghost" size="sm" className="text-gray-300 hover:bg-gray-700 hover:text-white">
                            <Home className="mr-2 h-4 w-4" />
                            Dashboard
                        </Button>
                    </Link>
                    <h1 className="text-lg font-semibold">{editorData.name}</h1>
                </div>
                <div>
                    <Button size="sm">Save Changes</Button>
                </div>
            </header>
            
            {/* Main Content */}
            <ResizablePanelGroup direction="horizontal" className="flex-grow">
                {/* Panel 1: Slide List */}
                <ResizablePanel defaultSize={20} minSize={15} maxSize={30}>
                    <div className="h-full bg-gray-800/50 p-4">
                       <h2 className="font-bold mb-4">Slides & Wines</h2>
                       <p>Slide List Panel (TODO)</p>
                    </div>
                </ResizablePanel>

                <ResizableHandle withHandle>
                    <GripVertical />
                </ResizableHandle>

                {/* Panel 2: Slide Preview */}
                <ResizablePanel defaultSize={50} minSize={30}>
                    <div className="h-full bg-gray-900 flex items-center justify-center p-8">
                        <div className="aspect-[9/16] w-full max-w-sm bg-gradient-primary rounded-2xl p-4">
                           <p>Slide Preview Panel (TODO)</p>
                           {activeSlide && <p>Selected: {activeSlide.payloadJson.title}</p>}
                        </div>
                    </div>
                </ResizablePanel>

                <ResizableHandle withHandle>
                     <GripVertical />
                </ResizableHandle>

                {/* Panel 3: Configuration */}
                <ResizablePanel defaultSize={30} minSize={20} maxSize={40}>
                     <div className="h-full bg-gray-800/50 p-4">
                        <h2 className="font-bold mb-4">Configuration</h2>
                        <p>Slide Config Panel (TODO)</p>
                         {activeSlide && <p>Editing: {activeSlide.payloadJson.title}</p>}
                    </div>
                </ResizablePanel>
            </ResizablePanelGroup>
        </div>
    );
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Typescript:client/src/pages/SlideEditor.tsx
IGNORE_WHEN_COPYING_END
Phase 3: Fixing the Sommelier Dashboard & Linking the Editor

Finally, let's fix the wine dropdown on the dashboard and add the "Edit" button to navigate to our new editor page.

1. Update client/src/pages/SommelierDashboard.tsx

import { useQuery } from "@tanstack/react-query";
import { motion } from "framer-motion";
import { Link } from "wouter";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { LoadingOverlay } from "@/components/ui/loading-overlay";
import { Wine, Edit, PlusCircle, Users } from "lucide-react";
import type { Package, PackageWine } from "@shared/schema";

type PackageWithWines = Package & { wines: PackageWine[] };

export default function SommelierDashboard() {
  const { data: packages = [], isLoading } = useQuery<PackageWithWines[]>({
    queryKey: ['/api/packages'],
  });

  if (isLoading) {
    return <LoadingOverlay isVisible={true} message="Loading packages..." />;
  }

  return (
    <div className="min-h-screen bg-gradient-primary p-4 sm:p-6 lg:p-8">
      <div className="max-w-7xl mx-auto">
        <div className="flex justify-between items-center mb-8">
          <h1 className="text-4xl font-bold text-white">Sommelier Dashboard</h1>
          <Button>
            <PlusCircle className="mr-2 h-4 w-4" />
            New Package
          </Button>
        </div>

        <motion.div 
          className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6"
          initial="hidden"
          animate="visible"
          variants={{
            hidden: {},
            visible: { transition: { staggerChildren: 0.1 } }
          }}
        >
          {packages.map((pkg) => (
            <motion.div key={pkg.id} variants={{ hidden: { opacity: 0, y: 20 }, visible: { opacity: 1, y: 0 } }}>
              <Card className="bg-gradient-card backdrop-blur-xl border-white/20 h-full flex flex-col">
                <CardHeader>
                  <CardTitle className="text-white">{pkg.name}</CardTitle>
                  <CardDescription className="text-purple-200">{pkg.description}</CardDescription>
                </CardHeader>
                <CardContent className="flex-grow">
                  <div className="flex items-center gap-2 mb-4">
                    <Wine className="text-purple-300" size={16}/>
                    <h4 className="text-sm font-medium text-white">Wines in this package:</h4>
                  </div>
                  {/* FIXED WINE DROPDOWN/LIST */}
                  <div className="flex flex-wrap gap-2">
                    {pkg.wines.length > 0 ? (
                      pkg.wines.map(wine => (
                        <Badge key={wine.id} variant="secondary" className="bg-white/10 text-white/80">
                          {wine.wineName}
                        </Badge>
                      ))
                    ) : (
                      <p className="text-white/50 text-sm">No wines added yet.</p>
                    )}
                  </div>
                </CardContent>
                <CardFooter className="flex justify-between">
                  <Badge variant="outline" className="text-white/70 border-white/30 font-mono tracking-widest">{pkg.code}</Badge>
                  <div className="flex gap-2">
                    <Button variant="outline" className="bg-white/10 border-white/20 text-white hover:bg-white/20">
                      <Users className="mr-2 h-4 w-4" />
                      Host
                    </Button>
                    {/* ADDED EDIT BUTTON */}
                    <Link href={`/editor/${pkg.code}`}>
                        <Button>
                            <Edit className="mr-2 h-4 w-4" />
                            Edit
                        </Button>
                    </Link>
                  </div>
                </CardFooter>
              </Card>
            </motion.div>
          ))}
        </motion.div>
      </div>
    </div>
  );
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Typescript:client/src/pages/SommelierDashboard.tsx
IGNORE_WHEN_COPYING_END

This completes the foundational work. The backend is now correctly seeded and exposing the necessary data. We have a dedicated, professional editor page ready to be built out, and the dashboard is fixed and correctly links to it. The next steps would be to build out the three panels of the editor, which I can do now that this solid foundation is in place.