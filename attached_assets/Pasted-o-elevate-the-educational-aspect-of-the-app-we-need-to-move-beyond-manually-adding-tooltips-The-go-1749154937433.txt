o elevate the educational aspect of the app, we need to move beyond manually adding tooltips. The goal is to create a system where any defined term (e.g., "body," "tannins") is automatically made interactive wherever it appears. This allows for a more maintainable and scalable solution, paving the way for sommeliers to eventually manage this glossary themselves, as discussed. The design of the tooltip itself must be polished and highly readable to fit the app's premium aesthetic.

What Needs to Be Done:

Update the Drizzle schema in shared/schema.ts to include the new glossary_terms table.
Create a backend API endpoint (GET /api/glossary) to fetch all glossary terms.
Implement a client-side global store or context to hold the glossary data.
Create a <DynamicTextRenderer /> component that takes a string, finds matches from the glossary, and wraps them with a redesigned <TerminologyTooltip />.
Integrate this DynamicTextRenderer into slide components.
How to Implement (Code Changes & Guidance):

Backend: Schema & API
File: shared/schema.ts
Action: Define the Drizzle schema for the new glossary_terms table to match the SQL provided above.
TypeScript

export const glossaryTerms = pgTable("glossary_terms", {
  id: uuid("id").primaryKey().defaultRandom(),
  term: text("term").notNull().unique(),
  variations: text("variations").array(), // For alternate spellings
  definition: text("definition").notNull(),
  category: varchar("category", { length: 50 }),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});
File: server/storage.ts
Action: Add a new method to the DatabaseStorage class to fetch all terms.
TypeScript

// Inside DatabaseStorage class
async getGlossaryTerms(): Promise<Array<typeof glossaryTerms.$inferSelect>> {
  return await db.select().from(glossaryTerms).orderBy(glossaryTerms.term);
}
File: server/routes.ts
Action: Create a new API endpoint to expose the glossary data.
TypeScript

// Inside registerRoutes function
app.get("/api/glossary", async (_req, res) => {
  try {
    const terms = await storage.getGlossaryTerms();
    res.json(terms);
  } catch (error) {
    console.error("Error fetching glossary:", error);
    res.status(500).json({ message: "Internal server error" });
  }
});
Frontend: Data Fetching & State Management
Action: In a top-level component like client/src/App.tsx, use react-query to fetch the glossary data once and make it available application-wide, potentially using a React Context or a state management library like Zustand if you prefer. For simplicity, a context is a good start.
Frontend: Create <DynamicTextRenderer /> Component
File: client/src/components/ui/DynamicTextRenderer.tsx (New File)
Functionality: This component will be the core of the auto-detection feature.
TypeScript

// Conceptual logic for DynamicTextRenderer.tsx
// 1. Accepts a `text: string` prop.
// 2. Fetches the glossary terms from the global context/store.
// 3. Creates a single, case-insensitive regular expression from all terms and their variations.
//    Example: const regex = new RegExp(`(${allTerms.join('|')})`, 'gi');
// 4. Uses `text.split(regex)` to break the text into parts (plain text and matched terms).
// 5. Maps over the resulting array, rendering plain text as-is and wrapping matched terms with your enhanced `<TerminologyTooltip />`.
Frontend: Enhance <TerminologyTooltip /> & Integrate
File: Update or create client/src/components/ui/TerminologyTooltip.tsx.
Action (UI/UX Enhancement):
Redesign the tooltip content (<TooltipContent>) to be beautiful and engaging. Use larger fonts, good contrast, and maybe a background gradient or texture that fits the app's aesthetic.
The trigger should be a subtle but clear underline, e.g., className="underline decoration-dotted decoration-purple-400/50 cursor-help".
File: client/src/components/questions/*.tsx & client/src/pages/TastingSession.tsx.
Action (Integration):
Replace direct text rendering like <p>{question.description}</p> with <DynamicTextRenderer text={question.description} />.
This needs to be done for question titles, descriptions, and potentially option descriptions.
Replit AI Guidance:
Prioritize the creation of the backend API and the client-side DynamicTextRenderer component.
For the tooltip's visual design, embrace modern UI principles: ensure high readability, use the app's color palette, and add subtle entrance/exit animations with Framer Motion.
The auto-detection logic using a single regex is key for performance.
