We're implementing a feature where hosts can control the status of a tasting session ('waiting', 'active', 'paused', 'completed'), and participants in TastingSession.tsx should see content based on this status. While parts of this were attempted, critical backend components are missing, and TastingSession.tsx has a bug.

Problem Areas:

Backend for Session Status:
The sessions table schema in shared/schema.ts may not have the status column yet.
The DatabaseStorage class in server/storage.ts is missing the implementation for an updateSessionStatus(sessionId: string, status: string) method.
The getSessionById method in server/storage.ts doesn't currently fetch or return the session status.
The server/routes.ts file is missing the PATCH /api/sessions/:sessionId/status API endpoint that HostDashboard.tsx tries to call.
TastingSession.tsx Slides Bug:
This component is still fetching slides for a hardcoded package "WINE01" (around lines 32-39) instead of using the packageCode from the currentSession object it fetches.
Objective (What):

Fully implement the backend infrastructure for managing and exposing session status.
Correct the TastingSession.tsx component to fetch slides dynamically based on the current session's actual package.
Ensure the Session type used in client-side queries for session data includes the status field.
Implementation Details (How):

Part 1: Backend Session Status Implementation

Update shared/schema.ts:

Modify the sessions table definition to include a status column:
TypeScript

// In sessions table definition
status: varchar("status", { length: 20 }).default('waiting').notNull(), // e.g., 'waiting', 'active', 'paused', 'completed'
Ensure your database-setup.sql also reflects this, or if the column was added manually via script by the AI, confirm it matches this definition. (The AI log indicates it tried: ALTER TABLE sessions ADD COLUMN IF NOT EXISTS status VARCHAR(20) DEFAULT 'waiting' NOT NULL;)
Update the Drizzle Session type and insertSessionSchema if necessary to reflect this new field.
Update server/storage.ts (DatabaseStorage class):

Modify IStorage Interface:
Ensure getSessionById return type is Promise<(Session & { packageCode?: string; status?: string }) | undefined>;.
Add updateSessionStatus(sessionId: string, status: string): Promise<Session | undefined>; (or Promise<void> if not returning the updated session).
Implement updateSessionStatus Method:
TypeScript

async updateSessionStatus(sessionId: string, status: string): Promise<Session | undefined> {
  // Add validation for allowed status values if desired
  const allowedStatuses = ['waiting', 'active', 'paused', 'completed'];
  if (!allowedStatuses.includes(status)) {
    throw new Error(`Invalid session status: ${status}`);
  }
  const updatedSessions = await db
    .update(sessions)
    .set({ status: status, updatedAt: new Date() }) // Also update updatedAt
    .where(eq(sessions.id, sessionId))
    .returning(); // Return the updated session
  return updatedSessions[0];
}
Modify getSessionById Method (around lines 218-239):
Add status: sessions.status to the select clause.
Ensure the returned object and its type correctly include the status.
TypeScript

// Inside getSessionById
// ...select clause...
select({
  // ... other fields ...
  status: sessions.status, // Add this
  packageCode: packages.code
})
// ...
// Update the constructed session object to include status: sessionData.status || 'waiting' (or similar default)
Add API Endpoint in server/routes.ts:

Create the PATCH /api/sessions/:sessionId/status endpoint:
TypeScript

app.patch("/api/sessions/:sessionId/status", async (req, res) => {
  try {
    const { sessionId } = req.params;
    const { status } = req.body; // Expecting { status: "new_status" } in body

    if (!status || typeof status !== 'string') {
      return res.status(400).json({ message: "Invalid status provided in request body." });
    }

    const updatedSession = await storage.updateSessionStatus(sessionId, status);
    if (!updatedSession) {
      return res.status(404).json({ message: "Session not found or failed to update." });
    }
    res.json(updatedSession);
  } catch (error: any) {
    console.error(`Error updating session ${req.params.sessionId} status:`, error);
    if (error.message?.includes('Invalid session status')) {
         return res.status(400).json({ message: error.message });
    }
    res.status(500).json({ message: "Internal server error updating session status." });
  }
});
Part 2: Frontend TastingSession.tsx Corrections

Update Session Query Type:

In client/src/pages/TastingSession.tsx (around line 20), change the type for currentSession query:
TypeScript

// Before: useQuery<Session & { packageCode?: string }>(...)
// After:
useQuery<Session & { packageCode?: string; status?: string }>(...)
Make Slides Query Dynamic:

In client/src/pages/TastingSession.tsx (around lines 32-39):
The queryKey and the queryFn for fetching slides currently hardcode "WINE01".
Modify these to use currentSession?.packageCode (which should be available from the currentSession query after the backend fix in Part 1).
Ensure the enabled condition for this query waits for currentSession?.packageCode.
TypeScript

// Change this:
// queryKey: [`/api/packages/WINE01/slides`],
// queryFn: async () => {
//   const response = await apiRequest('GET', `/api/packages/WINE01/slides?participantId=${participantId}`, null);
//   return response.json();
// },
// enabled: !!participantId

// To something like this:
queryKey: [`/api/packages/${currentSession?.packageCode}/slides`, participantId], // Add participantId to key if it influences caching for this user
queryFn: async () => {
  const response = await apiRequest('GET', `/api/packages/<span class="math-inline">\{currentSession?\.packageCode\}/slides?participantId\=</span>{participantId}`, null);
  return response.json();
},
enabled: !!currentSession?.packageCode && !!participantId,
Acceptance Criteria:

Backend:
The sessions table in the database (and shared/schema.ts) includes a status column.
The updateSessionStatus method in server/storage.ts correctly updates the session's status in the database.
The getSessionById method in server/storage.ts correctly fetches and returns the session status.
The PATCH /api/sessions/:sessionId/status API endpoint is functional and updates the session status.
Frontend - HostDashboard.tsx:
The Start/Pause/Reset session buttons correctly call the new PATCH API endpoint and update the session status on the backend.
The displayed session status on the Host Dashboard reflects the actual status from the database (due to refetchSession() on mutation success).
Frontend - TastingSession.tsx:
Correctly fetches the currentSession.status and currentSession.packageCode.
Correctly fetches slides for the dynamic currentSession.packageCode, no longer hardcoding "WINE01".
Displays the appropriate "waiting," "paused," or "completed" UI based on currentSession.status.
Only allows interaction with tasting slides if currentSession.status is 'active'.