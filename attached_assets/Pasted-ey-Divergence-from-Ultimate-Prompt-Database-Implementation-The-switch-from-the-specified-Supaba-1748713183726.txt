ey Divergence from "Ultimate Prompt":

Database Implementation: The switch from the specified Supabase/PostgreSQL persistence (using Drizzle ORM) to an in-memory WorkingStorage is the most critical issue. This affects data persistence, scalability, and the reliability of any feature relying on stored data (like analytics, session resume across server restarts).
Real-time Features (Socket.io) & Advanced Backend Components (Redis, Node-cron for ETL from prompt): These are largely absent from the current server setup in package.json and server/index.ts. The ETL logic in the prompt (scripts/etl/airtable-sync.js) is not present in the Replit file structure.
Frontend Routing: wouter is used instead of React Router v6 specified in the "Ultimate Prompt."
Offline Storage: useSessionPersistence.ts uses localStorage instead of the IndexedDB suggested in the "Ultimate Prompt."
UI Components: The ScaleQuestion.tsx uses a standard shadcn/ui slider, not the custom circular SVG slider detailed in the prompt.
I. Diagnosing Host Dashboard Refresh & Fixing Core Data Issues:
The constant refresh/reset on the HostDashboard.tsx is likely due to a combination of factors, primarily stemming from how data is fetched and the implications of the in-memory storage. The "Codex" notes correctly identify issues with useQuery keys.

Primary Suspected Causes for HostDashboard Refresh:

Incorrect useQuery Keys: As noted by "Codex," query keys like ['/api/sessions', sessionId] are problematic. react-query typically uses the entire array as a dependency. If the default query function in client/src/lib/queryClient.ts only uses queryKey[0] to construct the URL, it will repeatedly fetch /api/sessions instead of /api/sessions/${sessionId}. Even if the URL construction was correct, if sessionId itself is unstable (though it comes from useParams which should be stable), or if other parts of the key array are unstable objects/arrays, it can cause re-fetches.
refetchInterval: Several queries in HostDashboard.tsx have refetchInterval set (e.g., 5000ms for session, 3000ms for participants). While intended for real-time updates, if the underlying data or query keys are unstable, or if the fetched data causes significant state changes, this polling can lead to the observed reset/refresh behavior, especially with uncontrolled components like the Tabs.
Uncontrolled Tabs: The "Codex" note about uncontrolled tabs resetting on re-renders caused by polling is very likely accurate.
In-Memory Storage Side Effects: While not directly causing frontend refreshes, if API calls return inconsistent or "reset" data due to the server's in-memory state (e.g., if the server restarted or data was modified unexpectedly), it could lead to a confusing UX that appears like a reset.
Actionable Tasks for Host Dashboard & Core Data:
Task 1: Implement True Database Persistence with Drizzle ORM

Files: server/storage.ts, server/db.ts, shared/schema.ts.
Issue: server/storage.ts uses in-memory Maps instead of the Supabase/PostgreSQL database via Drizzle ORM.
Requirements:
Modify server/storage.ts to remove the WorkingStorage class and its in-memory Maps.
Implement all methods defined in the IStorage interface (e.g., getPackageByCode, createSession, getSlidesByPackageId, etc.) using Drizzle ORM queries to interact with the PostgreSQL database connected via server/db.ts.
Use the Drizzle schema defined in shared/schema.ts for all database operations.
Ensure all async functions correctly await database operations and return Promises.
Remove the initializeWineTastingData() method from storage.ts; initial data should be managed by database-setup.sql or a separate seeding script if dynamic seeding is needed.
Criteria: All data operations defined in IStorage are performed against the PostgreSQL database. Data persists across server restarts. The sample data from database-setup.sql is accessible via the API.