Currently, when a user navigates to the join flow (presumably handled by client/src/pages/SessionJoin.tsx), it leads to the creation of a new session based on a packageCode. This was diagnosed as the reason hosts and participants end up in separate sessions.

We have just updated HostDashboard.tsx (Task 14) to generate join links that include a specific sessionId in the URL, like /join?sessionId=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.

Now, SessionJoin.tsx needs to be modified to:

Detect if a sessionId is provided in the URL query parameters.
If a sessionId is present, the component should facilitate adding the current user as a new participant to that existing session, rather than creating a new session.
If no sessionId is present (e.g., user navigates to /join with only a packageCode or directly), the existing behavior of potentially creating a new session (or finding an open one for a package - though this "find open" logic isn't fully built) would apply, but this flow is secondary to joining via a direct session link.
Objective (What):
Refactor client/src/pages/SessionJoin.tsx to prioritize joining an existing session if a sessionId is provided in the URL query parameters.

Implementation Details (How):

Read sessionId from URL Query Parameters:

In SessionJoin.tsx, when the component mounts or when handling the join form submission, access the URL query parameters to check for sessionId.
The wouter router's useLocation hook or URLSearchParams(window.location.search) can be used.
TypeScript

// Example using URLSearchParams inside SessionJoin.tsx
import { useLocation as useWouterLocation } from "wouter"; // If needed for navigation
// ...
const [location, setLocation] = useWouterLocation();
const searchParams = new URLSearchParams(window.location.search);
const sessionIdFromUrl = searchParams.get('sessionId');
const packageCodeFromUrl = searchParams.get('code'); // Keep handling this for other scenarios if needed
Conditional Logic in Form Submission (onSubmit or equivalent):

If sessionIdFromUrl is present and valid:
The primary action upon form submission (after collecting participant's displayName, email, isHost status) should be to add the participant to the existing session.
This involves making a POST request to /api/sessions/:sessionId/participants (the endpoint around line 86 in server/routes.ts). The body of this request should include the participant's details (displayName, email, isHost: false for typical participants).
Remove or bypass any logic that calls createSessionMutation or POST /api/sessions if joining via sessionIdFromUrl.
Upon successful addition as a participant, navigate the user to the tasting session page: /tasting/:sessionId/:participantId (where participantId is returned from the /api/sessions/:sessionId/participants call).
If sessionIdFromUrl is NOT present (fallback or direct package code entry):
The component can retain its existing logic for handling joins via packageCode. This might involve:
Validating the packageCode.
Then, allowing a host to create a new session for this package code (if isHost is true).
Or, for a non-host, this flow is problematic as it would also create a new session. This specific fallback flow for non-hosts joining by packageCode without a sessionId needs careful consideration. For now, the priority is making sessionId joining work. The simplest fallback if no sessionId is to guide the user to get a session-specific link from a host.
For this task, the primary focus is the sessionIdFromUrl path.
Data Validation and API Calls:

When joining via sessionIdFromUrl:
Before attempting to add the participant, it might be good practice to first make a GET request to /api/sessions/:sessionIdFromUrl to verify the session exists and is active/joinable (optional, but improves robustness).
Use the apiRequest utility for the POST to /api/sessions/:sessionId/participants.
Handle API errors gracefully (e.g., session not found, failed to add participant) using toasts.
State Management:

The component will need to manage form inputs for displayName and email.
The isHost checkbox logic remains relevant if this page is also used by a host starting a new session (though the primary join flow for participants will have isHost: false).
Acceptance Criteria:

If a user navigates to /join?sessionId=SOME_EXISTING_SESSION_ID:
SessionJoin.tsx correctly extracts SOME_EXISTING_SESSION_ID.
Upon submitting their details (name, email), the component makes a POST request to /api/sessions/SOME_EXISTING_SESSION_ID/participants.
The participant is added to that existing session in the database.
The participant is navigated to the correct /tasting/SOME_EXISTING_SESSION_ID/THEIR_NEW_PARTICIPANT_ID page.
No new session is created in the database for this participant.
The existing functionality for initiating a new session via packageCode (primarily for a host starting a brand new tasting) should ideally still work or be clearly separated if SessionJoin.tsx becomes too complex. For this task, prioritize the sessionId join flow.
Error handling is in place for invalid sessionId or issues adding the participant.
